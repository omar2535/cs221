#include <cmath>
#include <vector>
#include "point.h"
#include "convexintersection.h"
#include <iostream>
#include "convexhull.h"
#include <algorithm>    
using namespace std;




//Checks whether the given point is inside the hull given 2 points that makes a counter-clockwise shape
bool inside(Point p1, Point sp1, Point sp2){
    // double p = (sp2.x - sp1.x)*(p1.y - sp1.y) - (sp2.y - sp1.y)*(p1.x - sp1.x);
    // bool isInside = p<=0;

    // bool isInDistance = false;
    // if(p<0){
    //     double maxDistance = sqrt(pow(sp2.x - sp1.x, 2) + pow(sp2.y - sp1.y, 2));
    //     double distance = sqrt(pow(p1.x - sp1.x, 2) + pow(p1.y - sp1.y, 2));
    //     isInDistance = distance < maxDistance;
    // }
    // return isInside && isInDistance;
    return !ccw(p1, sp1, sp2);
    //return isInside;
}

//returns point of intersection between 2 lines generated by 2 points for each line
Point computeIntersection(Point s1, Point s2, Point i1, Point i2){
    double Px = ((s1.x * s2.y - s1.y *s2.x)*(i1.x - i2.x) - (s1.x - s2.x)*(i1.x*i2.y - i1.y*i2.x))/((s1.x-s2.x)*(i1.y-i2.y)-(s1.y-s2.y)*(i1.x-i2.x));
    double Py = ((s1.x * s2.y - s1.y *s2.x)*(i1.y - i2.y) - (s1.y - s2.y)*(i1.x*i2.y - i1.y*i2.x))/((s1.x-s2.x)*(i1.y-i2.y)-(s1.y-s2.y)*(i1.x-i2.x));
    return Point(Px, Py);
}

Point computeIntersection2(Point s1, Point s2, Point i1, Point i2){
    double x;
    double y;
    if (s1.x == s2.x) {
        x = s1.x;
        double mi = (i2.y - i1.y) / (i2.x - i1.x);
        double bi = i1.y - (mi * i1.x);
        y = mi * x + bi;
    }
    if (i1.x == i2.x) {
        x = i1.x;
        double ms = (s2.y - s1.y) / (s2.x - s1.x);
        double bs = s1.y - (ms * s1.x);
        y = ms * x + bs;
    }
    if ( (i1.x != i2.x) && (s1.x != s2.x) ) {
        double ms = (s2.y - s1.y) / (s2.x - s1.x);
        double bs = s1.y - (ms * s1.x);

        double mi = (i2.y - i1.y) / (i2.x - i1.x);
        double bi = i1.y - (mi * i1.x);
        x = (bs - bi) / (mi - ms);
        y = ms * x + bs;
    }
    return Point(x, y);   
}

//Checks if inside entire hull
bool isInside(vector<Point> v, Point p){
    bool isInside = false;
    
    for(unsigned int i=0; i<v.size()-1; i++){
        if(inside(p, v.at(i), v.at(i+1))){
            isInside = true;
        }else{
            isInside = false;
            break;
        }
    }
    
    return isInside;
}


//true if vector contains point, false if not. O(n)
bool checkVectorContainsPoint(vector<Point> v, Point p){
    for(unsigned int i=0; i<v.size(); i++){
        if(v.at(i).x ==p.x && v.at(i).y == p.y){
            return true;
        }
    }
    return false;
}

//gets intersection points 
vector<Point> getConvexIntersection(vector<Point>& poly1, vector<Point>& poly2){

    if(poly1.size() != 0){
        poly1.push_back(poly1.at(0));
    }
    if(poly2.size() != 0){
        poly2.push_back(poly2.at(0));
    }
    vector<Point> outputList;


    for(int i=0; i<poly1.size(); i++){
        for(int x=0; x<poly2.size(); x++){
            Point curr = poly2.at(x);
            //if curr is inside poly1
            if(isInside(poly1, curr) && !checkVectorContainsPoint(outputList, curr)){
                outputList.push_back(curr);
            }
            //if there is an intersection
            if(x+1 < poly2.size() && i+1 < poly1.size()){
                if(!isInside(poly1, poly2.at(x+1))){
                    Point intersect = computeIntersection(poly1.at(i), poly1.at(i+1), poly2.at(x), poly2.at(x+1));
                    Point intersect2 = computeIntersection2(poly2.at(x), poly2.at(x+1), poly1.at(i), poly1.at(i+1));
                    if(isInside(poly2, intersect) && isInside(poly1, intersect)){
                        outputList.push_back(intersect);
                    }
                    else if(isInside(poly2, intersect2) && isInside(poly1, intersect2)){
                        outputList.push_back(intersect2);
                    }
                }
                if(!isInside(poly2, poly1.at(i+1))){
                    Point intersect = computeIntersection(poly2.at(x), poly2.at(x+1), poly1.at(i), poly1.at(i+1));
                    Point intersect2 = computeIntersection2(poly2.at(x), poly2.at(x+1), poly1.at(i), poly1.at(i+1));
                    if(isInside(poly2, intersect) && isInside(poly1, intersect)){
                        outputList.push_back(intersect);
                    }
                    else if(isInside(poly2, intersect2) && isInside(poly1, intersect2)){
                        outputList.push_back(intersect2);
                    }
                }
            }            
        }
        //if curr is inside poly2
        Point curr = poly1.at(i);
        if(isInside(poly2, curr)&& !checkVectorContainsPoint(outputList, curr)){
            outputList.push_back(curr);

        }
    }

    if(outputList.size() > 0)
    sortByAngle(outputList);



    for(int i=0; i<outputList.size(); i++){
        cout<<"X: "<<outputList.at(i).x<<" Y:"<<outputList.at(i).y<<endl;
    }
    cout<<"____________________________________"<<endl; 
    return outputList;

    
}
